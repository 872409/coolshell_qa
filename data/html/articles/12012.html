<!DOCTYPE html><!--[if IE 8]>
<html id="ie8" dir="ltr" lang="zh-CN"
	prefix="og: https://ogp.me/ns#" >
<![endif]--><!--[if !(IE 8) ]><!--><html dir="ltr" lang="zh-CN" prefix="og: https://ogp.me/ns#"><!--<![endif]--><head><meta charset="UTF-8"/><title>State Threads 回调终结者 | 酷 壳 - CoolShell</title><link rel="stylesheet" type="text/css" href="/assets/all.min.css"/><link rel="shortcut icon" href="/assets/favicon.png"/></head>
<body class="post-template-default single single-post postid-12012 single-format-standard group-blog">

<div id="page" class="hfeed site">

<div class="container">
<div class="row">

</div>
</div>
<div id="content" class="site-content">
<div class="container">
<div class="row">
<div id="primary" class="content-area  col-md-12" style="margin-top: 40px;">
<main id="main" role="main">
<article id="post-12012" class="post-content post-12012 post type-post status-publish format-standard hentry category-cplusplus category-unixlinux category-webdev category-progdesign tag-c tag-coroutine tag-edsm tag-ia tag-process-2 tag-thread tag-web tag-707">
<header class="entry-header">
<span class="screen-reader-text">State Threads 回调终结者</span>
<h1 class="entry-title">State Threads 回调终结者</h1>
<div class="entry-meta">
<h5 class="entry-date"><i class="fa fa-calendar-o"></i> <a href="/articles/12012.html" title="22:48" rel="bookmark"><time class="entry-date" datetime="2014-10-12T22:48:57+08:00" pubdate="">2014年10月12日 </time></a><span class="byline"><span class="sep"></span><i class="fa fa-user"></i>
<span class="author vcard"><a class="url fn n" href="/articles/author/full_of_bull" title="View all posts by Leo" rel="author">Leo</a></span></span> <i class="fa fa-comments-o"></i><span class="screen-reader-text">评论 </span> <a href="/articles/12012.html#comments" class="comments-link">50 条评论</a> <i class="fa fa-users" style="margin-left:10px;"></i> 54,743 人阅读</h5>
</div>
</header>
<div class="entry-content">
<p><strong>（感谢网友 </strong><a href="http://weibo.com/fullofbull" target="_blank"><strong>@我的上铺叫路遥</strong></a><strong> 投稿）</strong></p>
<p>上回写了篇<a title="一个“蝇量级” C 语言协程库" href="/articles/10975.html" target="_blank">《一个“蝇量级”C语言协程库》</a>，推荐了一下<a title="Protothreads" href="http://dunkels.com/adam/pt/" target="_blank">Protothreads</a>，通过coroutine模拟了用户级别的multi-threading模型，虽然本身足够“轻”，杜绝了系统开销，但这个库本身应用场合主要是内存限制的嵌入式领域，提供原生态组件太少，使用限制太多，比如依赖其它调用产生阻塞等。</p>
<p>这回又替大家在开源界淘了个宝，推荐一个轻量级网络应用框架<strong>State Threads</strong>（以下简称ST），总共也就3000行C代码，跟Protothreads不同在于ST针对的就是<strong>高性能可扩展服务器</strong>领域（值得一提的是Protothreads官网<a title="参考链接" href="http://dunkels.com/adam/pt/links.html" target="_blank">参考链接</a>上第一条就是ST的官网）。在其<a title="FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">FAQ</a>页面上一句引用”Perfection is achieved not when there is nothing more to add, but rather when there is nothing more to take away.”可以视为开发人员对ST源码质量的自信。</p>
<div id="ez-toc-container" class="ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction">
<div class="ez-toc-title-container">
<p class="ez-toc-title">目录</p>
<span class="ez-toc-title-toggle"></span></div>
<nav><ul class="ez-toc-list ez-toc-list-level-1 "><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-1" href="#%E5%8E%86%E5%8F%B2%E6%B8%8A%E6%BA%90" title="历史渊源">历史渊源</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-2" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88EDSM%EF%BC%89" title="基于事件驱动状态机（EDSM）">基于事件驱动状态机（EDSM）</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-3" href="#%E5%9F%BA%E4%BA%8EMult-Threading%E8%8C%83%E5%BC%8F" title="基于Mult-Threading范式">基于Mult-Threading范式</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-4" href="#%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%8E%AF%E5%A2%83" title="基于多核环境">基于多核环境</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-5" href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6" title="使用限制">使用限制</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-6" href="#%E6%80%BB%E7%BB%93" title="总结">总结</a></li><li class="ez-toc-page-1 ez-toc-heading-level-4"><a class="ez-toc-link ez-toc-heading-7" href="#%E5%8F%82%E8%80%83" title="参考">参考</a></li></ul></nav></div>
<h4><span class="ez-toc-section" id="%E5%8E%86%E5%8F%B2%E6%B8%8A%E6%BA%90"></span>历史渊源<span class="ez-toc-section-end"></span></h4>
<p>首先介绍一下这个库的历史渊源，从代码贡献者来看，ST不是个人作品，而是有着雄厚的商业支持和应用背景，比如服务器领域，在<a href="http://state-threads.sourceforge.net/news.html" target="_blank">这里</a>你可以看到ST曾作为Apache的多核应用模块发布。其诞生最初是由网景（Netscape）公司的MSPR（Netscape Portable Runtime library）项目中剥离出来，后由SGI（Silicon Graphic Inc）还有Yahoo!公司（前者是主力）开发维护的独立线程库。历史版本方面，作为<a title="SourceForge" href="http://sourceforge.net/projects/state-threads/files/" target="_blank">SourceForge</a>上开源项目，由2001年发布v1.0以来一直到2009年v1.9稳定版后未再变动。在平台移植方面，从Makefile的配置选项中可知ST支持多种Unix-like平台，还有专门针对Win32的源码改写。源码例子中，提供了web server、proxy以及dns三种编程实例供参考。可以说代码质量应该是相当的稳定和可靠的。</p>
<p><span id="more-12012"></span></p>
<p>至于许可证方面，有必要略作说明。出于历史原因，网景最初发布时选择了MPL1.1许可证，而后SGI在维护中又混进了GPLv2许可证，照理说这两种许可证是互不兼容的（MPL1.1后续版本是GPL兼容的），也就是说用双许可证打包发布理论上是非法无效的，见GNU官网上<a title="GPL兼容" href="http://www.gnu.org/licenses/license-list.html#MPL" target="_blank">MPL兼容性</a>一节。但这里有值得商榷的地方，因为文中又提及，根据MPL1.1中某条款第13节，如果整段或部分代码允许采用另一许可证作为备用（alternate）选择，比如GPL及其兼容，那么整个库的许可证就可视为GPL兼容的。如此一来所谓GPL兼容性一般解释为你不能在GPLv2的代码中混入MPL1.1，而不是说你不能在MPL1.1代码中混入GPLv2，也就是说GPLv2在MPL1.1之后是可以接受的，事实上SGI就采用了后面的做法，尚未引起版权上的纠纷。为此我还考证了一下FAQ上<a title="license" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">license</a>一节的说法，说ST既可以在MPL和GPL之间选择一种，也可以继续用双许可证，还补了一句在non-free项目使用上也没有限制，但对ST源码所做改动必须对用户可见。在源码文件中的SGI的附加声明还解释了将ST转为GPL代码的做法，就是可以删除前面MPL的声明，否则后续用户仍可以在两者之间二选一。个人觉得既然SGI都这样发话了，那么可解释为反之删除GPL的声明继续采用MPL也是可以接受的，如果你对双许可证承诺仍不放心的话。</p>
<h4><span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%8A%B6%E6%80%81%E6%9C%BA%EF%BC%88EDSM%EF%BC%89"></span>基于事件驱动状态机（EDSM）<span class="ez-toc-section-end"></span></h4>
<p>好了，下面该进入技术性话题了。前面说了ST的目标是<strong>高性能可扩展</strong>，其技术特征一言以蔽之就是</p>
<blockquote><p><strong>“It combines the simplicity of the multi-threaded programming paradigm, in which one thread supports each simultaneous connection, with the performance and scalability of an event-driven state machine (EDSM) architecture.”</strong></p></blockquote>
<p>我们先来纵向比较ST与传统的EDSM区别，再来横向比较与其它线程库（比如Pthread）的区别（注：以下图片全部来自<a title="ST FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">State Threads Library FAQ</a>）。</p>
<p>传统EDSM最常见的方式就是I/O事件的<strong>异步回调</strong>。基本上都会有一个叫做dispatcher的单线程主循环（又叫event loop），用户通过向dispatcher注册回调函数（又叫event handler）来实现异步通知，从而不必在原地空耗资源干等，在dispatcher主循环中通过select()/poll()系统调用来等待各种I/O事件的发生，当内核检测到事件触发并且数据可达或可用时，select()/poll()会返回从而使dispatcher调用相应的回调函数来对处理用户的请求。所以异步回调与其说是通知，不如说用委托更恰当。</p>
<p>整个过程都是单线程的。<strong>这种处理本质上就是将一堆互不相交（disjoint）的回调实现同步控制，就像串联在一个顺序链表上。</strong>见图1，黑色的双箭头表示I/O事件复用，回调是个筐，里面装着对各种请求的处理（当然不是每个请求都有回调，一个请求也可以对应不同的回调），每个回调被串联起来由dispatcher激活。这里请求等价于thread的概念（不是操作系统的线程），只不过“上下文切换”（context switch）发生在每个回调结束之时（假设不同请求对应不同回调），注册下一个回调以待事件触发时恢复其它请求的处理。至于dispatcher的执行状态（execute state）可作为回调函数的参数保存和传递。</p>
<p><img decoding="async" class="aligncenter" src="/uploads/2014/10/edsm.gif" alt="EDSM" srcset=""/></p>
<p>异步回调的缺陷在于<strong>难以实现和扩展</strong>，虽然已经有libevent这样的通用库，以及其它actor/reacotor的设计模式及其框架，但正如Dean Gaudet（Apache开发者）所说：“其内在的复杂性——<strong>将线性思维分解成一堆回调的负担</strong>（breaking up linear thought into a bucketload of callbacks）——仍然存在”。从上图可见，<strong>回调之间请求例程不是连续的，比如回调之间的切换会打断部分请求，又比如有新的请求需要重新注册。</strong></p>
<p><strong>ST本质上仍然是基于EDSM模型，但旨在取代传统的异步回调方式。</strong>ST将请求抽象为thread概念以更接近自然编程模式（所谓的linear thought吧，就像操作系统的线程之间切换那样自然）。ST的调度器（scheduler）对于用户来说是透明的，不像dispatcher那种将执行状态（execute state）暴露给回调方式。每个thread的现场环境可以保存在栈上（一段连续的大小确定的内存空间），由C的运行环境管理。从图2看到，<strong>ST的threads可以并发地线性地处理I/O事件，模型比异步回调简单得多。</strong></p>
<p><img decoding="async" class="aligncenter" src="/uploads/2014/10/st_edsm.gif" alt="State Threads" srcset=""/></p>
<p>这里稍微解释一下ST调度工作原理，ST运行环境维护了四种队列，分别是IOQ、RUNQ、SLEEPQ以及ZOMBIEQ，<strong>当每个thread处于不同队列中对应不同的状态（ST顾名思义所谓thread状态机）。</strong>比如polling请求的时候，当前thread就加入IOQ表示等待事件（如果有timeout同时会被放到SLEEPQ中），当事件触发时，thread就从IOQ（如果有timeout同时会从SLEEPQ）移除并转移到RUNQ等待被调度，成为当前的running thread，相当于操作系统的就绪队列，跟传统EDSM对应起来就是注册回调以及激活回调。再比如模拟同步控制wait/sleep/lock的时候，当前thread会被放入SLEEPQ，直到被唤醒或者超时再次进入RUNQ以待调度。</p>
<p><strong>ST的调度具备性能与内存双重优点</strong>：在性能上，ST实现自己的setjmp/longjmp来模拟调度，无任何系统开销，并且context（就是jmp_buf）针对不同平台和架构用底层语言实现的，可移植性媲美libc。下面放一段代码解释一下调度实现：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/*
 * Switch away from the current thread context by saving its state 
 * and calling the thread scheduler
 */
#define _ST_SWITCH_CONTEXT(_thread)       \
    ST_BEGIN_MACRO                        \
    if (!MD_SETJMP((_thread)-&gt;context)) { \
      _st_vp_schedule();                  \
    }                                     \
    ST_END_MACRO

/*
 * Restore a thread context that was saved by _ST_SWITCH_CONTEXT 
 * or initialized by _ST_INIT_CONTEXT
 */
#define _ST_RESTORE_CONTEXT(_thread)   \
    ST_BEGIN_MACRO                     \
    _ST_SET_CURRENT_THREAD(_thread);   \
    MD_LONGJMP((_thread)-&gt;context, 1); \
    ST_END_MACRO

void _st_vp_schedule(void)
{
    _st_thread_t *thread;

    if (_ST_RUNQ.next != &amp;_ST_RUNQ) {
        /* Pull thread off of the run queue */
        thread = _ST_THREAD_PTR(_ST_RUNQ.next);
        _ST_DEL_RUNQ(thread);
    } else {
        /* If there are no threads to run, switch to the idle thread */
        thread = _st_this_vp.idle_thread;
    }
    ST_ASSERT(thread-&gt;state == _ST_ST_RUNNABLE);

    /* Resume the thread */
    thread-&gt;state = _ST_ST_RUNNING;
    _ST_RESTORE_CONTEXT(thread);
}
</pre>
<p>如果你熟悉setjmp/longjmp的用法，你就知道当前thread在调用MD_SETJMP将现场上下文保存在jmp_buf中并返回返回0，然后自己调用_st_vp_schedule()将自己调度出去。调度器先从RUNQ上找，如果队列为空就找idle thread，这是在整个ST初始化时创建的一个特殊thread，然后将当前线程设为自己，再调用MD_LONGJMP切换到其上次调用MD_SETJMP的地方，从thread-&gt;context恢复现场并返回1，该thread就接着往下执行了。<strong>整个过程就同EDSM一样发生在操作系统单线程下，所以没有任何系统开销与阻塞。</strong></p>
<p><strong>其实真正的阻塞是发生在等待I/O事件复用上，也就是select()/poll()，这是整个ST唯一的系统调用。</strong>ST当前的状态是，整个环境处于空闲状态，所有threads的请求处理都已经完成，也就是RUNQ为空。这时在_st_idle_thread_start维护了一个主循环（类似于event loop），主要负责三种任务：1.对IOQ所有thread进行I/O复用检测；2.对SLEEPQ进行超时检查；3.将idle thread调度出去，代码如下：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">void *_st_idle_thread_start(void *arg)
{
    _st_thread_t *me = _ST_CURRENT_THREAD();

    while (_st_active_count &gt; 0) {
        /* Idle vp till I/O is ready or the smallest timeout expired */
        _ST_VP_IDLE();

        /* Check sleep queue for expired threads */
        _st_vp_check_clock();

        me-&gt;state = _ST_ST_RUNNABLE;
        _ST_SWITCH_CONTEXT(me);
    }

    /* No more threads */
    exit(0);

    /* NOTREACHED */
    return NULL;
}</pre>
<p>这里的me就是idle thread，因为_st_idle_thread_start就是创建idle thread的启动点，每从上次_ST_SWITCH_CONTEXT()切换回来的时候，接着在_ST_VP_IDLE()里轮询I/O事件的发生，一旦检测到发生了别的thread事件或者SLEEPQ里面发生超时，再用_ST_SWITCH_CONTEXT()把自己切换出去，如果此时RUNQ中非空的话就切换到队列第一个thread。这里主循环是不会退出的。</p>
<p>在内存方面，<strong>ST的执行状态作为局部变量保存在栈上，而不是像回调需要动态分配，</strong>用户可能分别这样使用thread模式和callback模式：</p>
<pre data-enlighter-language="c" class="EnlighterJSRAW">/* thread land */
int foo()
{
    int local1;
    int local2;
    do_some_io();
}

/* callback land */
struct foo_data {
    int local1;
    int local2;
};

void foo_cb(void *arg)
{
    struct foo_data *locals = arg;
    ...
}

void foo()
{
    struct foo_data *locals = malloc(sizeof(struct foo_data));
    register(foo_cb, locals);
}
</pre>
<h4><span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8EMult-Threading%E8%8C%83%E5%BC%8F"></span>基于Mult-Threading范式<span class="ez-toc-section-end"></span></h4>
<p>同样基于multi-threading编程范式，ST同其它线程库又有和有点呢？比如Posix Thread（以下简称PThread）是个通用的线程库，它是<strong>将用户级线程（thread）同内核执行对象（kernel execution entity，有些书又叫lightweight processes）做了1:1或m:n映射，</strong>从而实现multi-threading模式。<strong>而ST是单线程（n:1映射），它的thread实际上就是协程（coroutine）。</strong>通常的网络应用上，多线程范式绕不开操作系统，但在某些特定的服务器领域，线程间的共享资源会带来额外复杂度，锁、竞态、并发、文件句柄、全局变量、管道、信号等，面对这些Pthread的灵活性会大打折扣。<strong>而ST的调度是精确的，它只会在明确的I/O和同步函数调用点上发生上下文切换，这正是协程的特性，如此一来ST就不需要互斥保护了，进而也可以放心使用任何静态变量和不可重入库函数了</strong>（这在同样作为协程的Protothreads里是不允许的，因为那是stack-less的，无法保存上下文），极大的简化了编程和调试同时增加了性能。</p>
<p>对于同样用户级线程如GNU Pth和MIT Phread比起来呢？有两点，一是ST的thread是<strong>无优先级的非抢占式调度</strong>，也就是说ST基于EDSM的，每个thread都是事件或数据驱动，迟早会把自己调度出去，而且调度点是明确的，并非按时间片来的，从而简化了thread管理；二是ST会<strong>忽略所有信号处理</strong>，在_st_io_init中会把sigact.sa_handler设为SIG_IGN，这样做是因为将thread资源最小化，避免了signal mask及其系统调用（在ucontext上是避免不了的）。但这并不意味着ST就不能处理信号，实际上ST建议将信号写入pipe的方式转化为普通I/O事件处理，示例详见<a title="signal handling" href="http://state-threads.sourceforge.net/docs/notes.html#signals" target="_blank">这里</a>。</p>
<p>这里顺便说一句，<strong>C语言实现的协程据我所知只有三种方式</strong>：Protothread为代表利用switch-case语义跳转，以ST为代表不依赖libc的setjmp/longjmp上下文切换，以及依赖glibc的ucontext接口（<a title="云风的coroutine" href="https://github.com/cloudwu/coroutine" target="_blank">云风的coroutine</a>）。第一种最轻，但受限最大，第三种耗资源性能慢（陈皓注：glibc的ucontext接口的实现中有一个和信号有关的系统调用，所以会慢，估计在一些情况下会比pthread还慢），目前看来ST是最好使的。</p>
<h4><span class="ez-toc-section" id="%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E7%8E%AF%E5%A2%83"></span>基于多核环境<span class="ez-toc-section-end"></span></h4>
<p>下面来聊聊ST在多核环境下的应用。服务器领域多核的优势在于实现了物理上真正的并发，所以如何充分利用系统优势也是线程库的一大难点。这对ST来说也许正是它的拿手好戏，前面提及ST曾作为Apache的多核引擎模块发布。这里要补充一下前面漏掉的ST的一个重要概念——<strong>虚拟处理器</strong>（virtual processor，简称vp），见图3，多个cpu通过内核的SMP模拟出多个“核”（core），一个core对应一个内核任务（kernel task），同时对应一个用户进程（process），一个process对应ST的一个vp，每个vp下就是ST的thread（是协程不是线程），结合前面所述，vp初始化先创建idle thread，然后根据I/O事件驱动其它threads，这就是ST的多核架构。</p>
<p><img decoding="async" class="aligncenter" src="/uploads/2014/10/st_app.gif" alt="multi-core" srcset=""/></p>
<p>这里要指出的是，<strong>ST只负责自身thread调度，进程管理是应用程序的事情，</strong>也就是说由用户来决定fork多少进程，每个进程分配多少资源，如何进行IPC等。这种架构的好处就是每个vp有自己独立的空间，避免了资源同步竞态（比如杜绝了多进程里的多线程这样混乱的模型）。我们知道这种<strong>基于进程的架构是非常健壮的，一个进程奔溃不会影响到其它进程，同时充分利用多核硬件的高并发。</strong>同时对于具体逻辑业务使用vp里的thread处理，这是基于EDSM的，如此一来做到了<strong>逻辑业务与内核执行对象之间的解耦</strong>，没必要因为1K个连接去创建1K的进程。这就是ST的扩展性和灵活性。</p>
<h4><span class="ez-toc-section" id="%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"></span>使用限制<span class="ez-toc-section-end"></span></h4>
<p>ST的主要限制在于，应用程序所有I/O操作必须使用ST提供的API，因为只有这样thread才能被调度器管理，并且避免阻塞。</p>
<p>另一个限制在于thread调试，这本身不容易，好在v1.9的ST提供了DEBUG参数，使用TREADQ以及_st_iterate_threads接口检测thread调度情况，用户还可自定义_st_show_thread_stack接口dump每个thread的栈，在GDB使能_st_iterate_threads_flag变量，这些都在Readme中对调试方法有具体说明。按下不表。</p>
<h4><span class="ez-toc-section" id="%E6%80%BB%E7%BB%93"></span>总结<span class="ez-toc-section-end"></span></h4>
<p>这篇文章写得有点短了，主要是通过对比来介绍ST的，其实还有大段原理可以讲，大段源码以及实战用例可以贴，但这一下子又写不过来，ST还是有点技术含量的。说白了，<strong>ST的核心思想就是利用multi-threading的简单优雅范式胜过传统异步回调的复杂晦涩实现，又利用EDSM的性能和解耦架构避免了multi-threading在系统上的开销和暗礁。</strong>学习ST告诉我们一个道理：<strong>未来技术的趋势永远都是融合的。</strong></p>
<h4><span class="ez-toc-section" id="%E5%8F%82%E8%80%83"></span>参考<span class="ez-toc-section-end"></span></h4>
<ul>
<li>在<a title="sourceforge源码" href="http://sourceforge.net/projects/state-threads/files/" target="_blank">SourceForge</a>以及<a title="github源码" href="https://github.com/winlinvip/state-threads" target="_blank">github</a>上的源码：前者有历史版本及win32版本，后者只有v1.9。</li>
</ul>
<ul>
<li><a title="State Threads for Internet Applications" href="http://state-threads.sourceforge.net/docs/st.html" target="_blank">State Threads for Internet Applications</a>：介绍原理的，值得一看，<a title="中文翻译" href="http://blog.csdn.net/win_lin/article/details/8242653" target="_blank">这里</a>有篇中文翻译附加单元测试（在单CPU 512M内存上创建数万个thread，CPU占用率约5%，内存约4.3K/thread）。</li>
</ul>
<ul>
<li><a title="State Threads Library FAQ" href="http://state-threads.sourceforge.net/docs/faq.html" target="_blank">State Threads Library FAQ</a>：本文基于此而写。</li>
</ul>
<ul>
<li><a title="API手册" href="http://state-threads.sourceforge.net/docs/reference.html" target="_blank">Complete reference</a>：API完全手册。</li>
</ul>
<ul>
<li><a title="注意事项" href="http://state-threads.sourceforge.net/docs/notes.html" target="_blank">Programing Notes</a>：编程注意事项，包括信号处理，IPC，非网络I/O事件等。</li>
</ul>
<p>（全文完）</p>
<div style="margin-top: 15px; font-size: 16px;color: #cc0000;">
<p align="center"><strong>（转载本站文章请注明作者和出处 <a href="/">酷 壳 – CoolShell</a> ，请勿用于任何商业用途）</strong></p>
</div>

<div id="post-ratings-12012-loading" class="post-ratings-loading"><img src="https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif" width="16" height="16" class="post-ratings-image"/>Loading...</div>
</div>
<footer class="entry-footer">
<hr/><div class="row"><div class="col-md-6 cattegories"><span class="cat-links"><i class="fa fa-folder-open"></i>
<a href="javascript:void(0)" rel="category tag">C/C++语言</a>, <a href="javascript:void(0)" rel="category tag">Unix/Linux</a>, <a href="javascript:void(0)" rel="category tag">Web开发</a>, <a href="javascript:void(0)" rel="category tag">程序设计</a></span></div><div class="col-md-6 tags"><span class="tags-links"><i class="fa fa-tags"></i> <a href="javascript:void(0)" rel="tag">C++</a>, <a href="javascript:void(0)" rel="tag">coroutine</a>, <a href="javascript:void(0)" rel="tag">EDSM</a>, <a href="javascript:void(0)" rel="tag">IA</a>, <a href="javascript:void(0)" rel="tag">process</a>, <a href="javascript:void(0)" rel="tag">thread</a>, <a href="javascript:void(0)" rel="tag">Web</a>, <a href="javascript:void(0)" rel="tag">协程</a></span></div></div> </footer>
</article>

<div class="fixed"></div> 
</main>

<div class="post-comments">
<div id="comments" class="comments-area">
<h2 class="comments-title">
《<span>State Threads 回调终结者</span>》的相关评论 </h2>
<ol class="comment-list">
<li id="comment-1569875" class="comment even thread-even depth-1">
<article id="div-comment-1569875" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/9046943d03a5d41827ff251bfbff1d6c?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/9046943d03a5d41827ff251bfbff1d6c?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">int64ago</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1569875"><time datetime="2014-10-13T01:10:54+08:00">2014年10月13日 01:10</time></a> </div>
</footer>
<div class="comment-content">
<p>好文章！<br/>
就这种长度就正好，太长了也没必要</p>
</div>
 </article>
</li>
<li id="comment-1570109" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570109" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/6355b7e5921dcbb6a3428bea26ed7ab0?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/6355b7e5921dcbb6a3428bea26ed7ab0?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">gqjjqg</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570109"><time datetime="2014-10-13T08:42:10+08:00">2014年10月13日 08:42</time></a> </div>
</footer>
<div class="comment-content">
<p>好吧，又可以学习了。</p>
</div>
 </article>
</li>
<li id="comment-1570168" class="pingback even thread-even depth-1">
<div class="comment-body">
Pingback： <a href="http://wzzblog.sinaapp.com/static/14926.html" class="url" rel="ugc external nofollow">State Threads 回调终结者 | | Evolution Unit 进化Evolution Unit 进化</a> </div>
</li>
<li id="comment-1570184" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570184" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/1f846db4815aeadf4dfca3004b4ced01?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/1f846db4815aeadf4dfca3004b4ced01?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">mania</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570184"><time datetime="2014-10-13T10:33:31+08:00">2014年10月13日 10:33</time></a> </div>
</footer>
<div class="comment-content">
<p>每一篇都是精神food。</p>
</div>
 </article>
</li>
<li id="comment-1570248" class="comment even thread-even depth-1">
<article id="div-comment-1570248" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f55a6fc26cd76fa54ee3d3dac005ea03?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f55a6fc26cd76fa54ee3d3dac005ea03?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://argcv.com" class="url" rel="ugc external nofollow">Yu</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570248"><time datetime="2014-10-13T11:36:16+08:00">2014年10月13日 11:36</time></a> </div>
</footer>
<div class="comment-content">
<p>赞.<br/>
相比于协程而言，还是充分利用多核的thread好用。<br/>
此外，多进程间的通讯貌似没看到，不知道是不是我太粗心了</p>
</div>
 </article>
</li>
<li id="comment-1570315" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570315" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://oops_geekchina@googlegroups.com" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570315"><time datetime="2014-10-13T13:42:34+08:00">2014年10月13日 13:42</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1570248" rel="nofollow">@Yu </a><br/>
进程管理不属于ST范畴。</p>
</div>
 </article>
</li>
<li id="comment-1570331" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1570331" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://oops_geekchina@googlegroups.com" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570331"><time datetime="2014-10-13T13:56:09+08:00">2014年10月13日 13:56</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1570248" rel="nofollow">@Yu </a><br/>
就通用性而言协程不能完全代替线程，但线程的资源共享和竞态会让你的头发变灰。</p>
</div>
 </article>
</li>
<li id="comment-1570352" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570352" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/15651704a60f7ef1539f9b1fa2506188?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/15651704a60f7ef1539f9b1fa2506188?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">taowen</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570352"><time datetime="2014-10-13T14:30:39+08:00">2014年10月13日 14:30</time></a> </div>
</footer>
<div class="comment-content">
<p>c的协程库还有一个pypy项目里的stacklet<br/>
有人拿这个做了一个libgevent<br/>
<a href="https://github.com/denik/libgevent" rel="nofollow ugc">https://github.com/denik/libgevent</a></p>
</div>
 </article>
</li>
<li id="comment-1570355" class="comment even thread-even depth-1">
<article id="div-comment-1570355" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/cd6b562863e40798d37483604310d21d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/cd6b562863e40798d37483604310d21d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">Wilem</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570355"><time datetime="2014-10-13T14:34:03+08:00">2014年10月13日 14:34</time></a> </div>
</footer>
<div class="comment-content">
<p>二级标题：”基于Mult-Threading范式” -&gt; “基于Multi-Threading范式”</p>
</div>
 </article>
</li>
<li id="comment-1570363" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570363" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://oops_geekchina@googlegroups.com" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570363"><time datetime="2014-10-13T14:48:58+08:00">2014年10月13日 14:48</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1570352" rel="nofollow">@taowen </a><br/>
那个是伪thread，本质上仍是callback，毕竟是基于libuv</p>
</div>
 </article>
</li>
<li id="comment-1570458" class="comment even thread-even depth-1">
<article id="div-comment-1570458" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/e53cccb36f9e6583f00906c3a0f7eef9?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/e53cccb36f9e6583f00906c3a0f7eef9?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">ti</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570458"><time datetime="2014-10-13T16:35:23+08:00">2014年10月13日 16:35</time></a> </div>
</footer>
<div class="comment-content">
<p>2个thread如果不在同一个vp下，应该还是需要锁吧？</p>
</div>
 </article>
</li>
<li id="comment-1570465" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1570465" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570465"><time datetime="2014-10-13T16:42:36+08:00">2014年10月13日 16:42</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1570458" rel="nofollow">@ti </a><br/>
假设vp是和用户进程对应的，那要看你怎么用多进程了，这不是ST关注的。</p>
</div>
 </article>
</li>
<li id="comment-1570547" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1570547" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1570547"><time datetime="2014-10-13T18:09:25+08:00">2014年10月13日 18:09</time></a> </div>
</footer>
<div class="comment-content">
<p>测试中发现每个thread默认栈大小为65536字节，且用mmap匿名分配，这样大约创建32800个thread就返回失败，用malloc还行。除非把栈改小些。</p>
</div>
 </article>
</li>
<li id="comment-1572218" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1572218" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/0cdadf488169697a6293dcbf1f9e9356?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/0cdadf488169697a6293dcbf1f9e9356?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://JustYY.com" class="url" rel="ugc external nofollow">JustYY.com 小赖子的英国生活和资讯。</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1572218"><time datetime="2014-10-15T07:49:36+08:00">2014年10月15日 07:49</time></a> </div>
</footer>
<div class="comment-content">
<p>好文章，先收下慢慢看。</p>
</div>
 </article>
</li>
<li id="comment-1572648" class="comment even thread-even depth-1">
<article id="div-comment-1572648" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/29117001b92b80b3c8f7e78b9f46caea?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/29117001b92b80b3c8f7e78b9f46caea?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">homing</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1572648"><time datetime="2014-10-15T16:16:19+08:00">2014年10月15日 16:16</time></a> </div>
</footer>
<div class="comment-content">
<p>这个思路真是不错，从最底层的跳转方式入手改变，对于多thread的方式确实是很好的补充，用起来会方便不少。</p>
</div>
 </article>
</li>
<li id="comment-1573477" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1573477" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">zhouzhenghui</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1573477"><time datetime="2014-10-16T13:47:19+08:00">2014年10月16日 13:47</time></a> </div>
</footer>
<div class="comment-content">
<p>有进步，但这种妄图把调度和IO混为一谈的做法注定是不彻底的。</p>
</div>
 </article>
</li>
<li id="comment-1573532" class="comment even thread-even depth-1">
<article id="div-comment-1573532" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/0aabf802020a2c6e2cd3893ed2f13ff4?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/0aabf802020a2c6e2cd3893ed2f13ff4?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">starshine</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1573532"><time datetime="2014-10-16T15:03:09+08:00">2014年10月16日 15:03</time></a> </div>
</footer>
<div class="comment-content">
<p>确实不错，读了st的代码，以及其代码里一个server的example，又来重读了一遍这篇blog，<br/>
受益匪浅。感谢作者 &amp;&amp; 博主。<br/>
—-<br/>
另：很多后台服务的性能点，其实不在异步IO上，这类服务的client数量往往是固定或可预期的，比如10个等。而这类服务的性能点往往在于cpu计算，一个socket请求过来，大量密集的cpu计算，才能response这个socket。<br/>
因此，未来非常希望博主写一些： 如何将一个特定计算任务进行巧妙的粒度拆分，然后并行执行这些unit以提高性能的文章。</p>
</div>
 </article>
</li>
<li id="comment-1573599" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1573599" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1573599"><time datetime="2014-10-16T16:43:00+08:00">2014年10月16日 16:43</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1573477" rel="nofollow">@zhouzhenghui </a><br/>
ST针对事件和数据驱动场合，没说能处理所有I/O</p>
<p><a href="#comment-1573532" rel="nofollow">@starshine </a><br/>
我觉得性能主要还是在I/O上吧，CPU一般来说不太会是瓶颈。</p>
</div>
 </article>
</li>
<li id="comment-1573826" class="comment even thread-even depth-1">
<article id="div-comment-1573826" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">zhouzhenghui</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1573826"><time datetime="2014-10-16T21:01:30+08:00">2014年10月16日 21:01</time></a> </div>
</footer>
<div class="comment-content">
<blockquote cite="#commentbody-1573599"><p>
<strong><a href="#comment-1573599" rel="nofollow">Leo</a> :</strong><br/>
<a href="#comment-1573477" rel="nofollow">@zhouzhenghui </a><br/>
ST针对事件和数据驱动场合，没说能处理所有I/O<br/>
<a href="#comment-1573532" rel="nofollow">@starshine </a><br/>
我觉得性能主要还是在I/O上吧，CPU一般来说不太会是瓶颈。
</p></blockquote>
<p>和你的看法相反，我没有看到ST中泛化的事件概念，才是我质疑的地方。I/O虽然是事件的主要发起者，但并不涵盖所有，甚至不应该是程序直接面对的。我相信ST内部是有这个抽象的，但却没有暴露出来，体现了设计的局限，我看项目自身也定位于网络服务器的概念。</p>
<p>我是认同starshine的的观点，其中和上面说的有部分重叠。如果有兴趣不妨关注一下我的项目github.com/zhouzhenghui。</p>
</div>
 </article>
</li>
<li id="comment-1573908" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1573908" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a754df62bcca482e53736b7f53673cc5?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a754df62bcca482e53736b7f53673cc5?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://axb.me" class="url" rel="ugc external nofollow">ChanneW</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1573908"><time datetime="2014-10-16T23:09:22+08:00">2014年10月16日 23:09</time></a> </div>
</footer>
<div class="comment-content">
<p>涨姿势了~</p>
</div>
 </article>
</li>
<li id="comment-1574730" class="comment even thread-even depth-1">
<article id="div-comment-1574730" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/1246f4e71c1a04a18ee1a50929716c2a?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/1246f4e71c1a04a18ee1a50929716c2a?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">feng</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1574730"><time datetime="2014-10-17T09:58:47+08:00">2014年10月17日 09:58</time></a> </div>
</footer>
<div class="comment-content">
<p>这就是我一直在寻找的解决方案啊</p>
</div>
 </article>
</li>
<li id="comment-1575005" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1575005" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/cf1d2d429b000f1a4519d0bb9d187bb0?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/cf1d2d429b000f1a4519d0bb9d187bb0?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">Martin</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575005"><time datetime="2014-10-17T16:30:22+08:00">2014年10月17日 16:30</time></a> </div>
</footer>
<div class="comment-content">
<p>看完以后说说自己的理解，看看是不是理解对了，有问题请指正一下，谢鞋<br/>
就是通过多线程的方式取代传统模式下state maching的方式<br/>
传统方式就是注册回调，通过状态转化，激活当前状态需要对应的回调。<br/>
当前线程的状态由四种不同类型的线程队列的状态（是否为空）取而代之<br/>
然后通过一个event loop 对4个队列进行轮询<br/>
减小系统调用select/poll次数提高性能，从而线程切换使用MD_JMP实现，弥补多线程切换造成的性能损耗</p>
</div>
 </article>
</li>
<li id="comment-1575013" class="comment even thread-even depth-1">
<article id="div-comment-1575013" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/cf1d2d429b000f1a4519d0bb9d187bb0?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/cf1d2d429b000f1a4519d0bb9d187bb0?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">Martin</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575013"><time datetime="2014-10-17T16:41:20+08:00">2014年10月17日 16:41</time></a> </div>
</footer>
<div class="comment-content">
<p>在总结一下，就是使用单线程优势以及编程便利性来实现多线程的性能，可以这么理解么？</p>
</div>
 </article>
</li>
<li id="comment-1575077" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1575077" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">zhouzhenghui</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575077"><time datetime="2014-10-17T17:50:52+08:00">2014年10月17日 17:50</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1573599" rel="nofollow">@Leo </a><br/>
和你的看法相反，我没有看到ST中泛化的事件概念，才是我质疑的地方。I/O虽然是事件的主要发起者，但并不涵盖所有，甚至不应该是程序直接面对的。我相信ST内部是有这个抽象的，但却没有暴露出来，体现了设计的局限，我看项目自身也定位于网络服务器的概念。</p>
<p>我是认同starshine的的观点，其中和上面说的有部分重叠。</p>
</div>
 </article>
</li>
<li id="comment-1575084" class="comment even thread-even depth-1">
<article id="div-comment-1575084" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://github.com/zhouzhenghui" class="url" rel="ugc external nofollow">zhouzhenghui</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575084"><time datetime="2014-10-17T17:53:27+08:00">2014年10月17日 17:53</time></a> </div>
</footer>
<div class="comment-content">
<p>有兴趣可以参见我的链接。</p>
</div>
 </article>
</li>
<li id="comment-1575166" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1575166" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f55a6fc26cd76fa54ee3d3dac005ea03?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f55a6fc26cd76fa54ee3d3dac005ea03?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://argcv.com" class="url" rel="ugc external nofollow">Yu</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575166"><time datetime="2014-10-17T20:12:16+08:00">2014年10月17日 20:12</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1570331" rel="nofollow">@Leo </a><br/>
多谢解惑。</p>
</div>
 </article>
</li>
<li id="comment-1575694" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1575694" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575694"><time datetime="2014-10-18T10:25:28+08:00">2014年10月18日 10:25</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1575084" rel="nofollow">@zhouzhenghui </a><br/>
ST的确无法处理中断、信号等内核层面的事件（信号是可以写pipe方式转化为I/O），可能也没有向你所说泛华事件概念。文档中也说明ST定位的是网络服务器，这样一来性能要比概念泛化更重要，用closure模拟回调的做法不熟悉，性能不知能否满足，毕竟跟setjmp/longjmp跳转比较，函数调用在C中本身是一笔开销。</p>
</div>
 </article>
</li>
<li id="comment-1575701" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1575701" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575701"><time datetime="2014-10-18T10:30:37+08:00">2014年10月18日 10:30</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1575077" rel="nofollow">@zhouzhenghui </a><br/>
ST的jump是用底层代码实现的，不依赖库函数调用。</p>
</div>
 </article>
</li>
<li id="comment-1575709" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1575709" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575709"><time datetime="2014-10-18T10:40:21+08:00">2014年10月18日 10:40</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1575005" rel="nofollow">@Martin </a><br/>
不是对四个队列进行轮询，具体见源码。<br/>
本质是用multi-threading范式实现EDSM机制。</p>
</div>
 </article>
</li>
<li id="comment-1575724" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1575724" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1575724"><time datetime="2014-10-18T10:54:00+08:00">2014年10月18日 10:54</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1575077" rel="nofollow">@zhouzhenghui </a><br/>
如果是用C/C++来实现closure的话，内部的数据是static的吧，而不是在堆栈上。</p>
</div>
 </article>
</li>
<li id="comment-1576070" class="comment even thread-even depth-1">
<article id="div-comment-1576070" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/f6e8f50be1751f1bb1648b0fb473850d?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="https://github.com/zhouzhenghui" class="url" rel="ugc external nofollow">zhouzhenghui</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1576070"><time datetime="2014-10-18T17:20:47+08:00">2014年10月18日 17:20</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1575724" rel="nofollow">@Leo </a><br/>
你说的都有局限性，这里不适合讨论，如有兴趣可以私下交流。</p>
</div>
 </article>
</li>
<li id="comment-1580522" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1580522" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/e93c5adc34e87abc1e19a0d6e1be857a?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/e93c5adc34e87abc1e19a0d6e1be857a?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">liu.gong</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1580522"><time datetime="2014-10-22T23:58:03+08:00">2014年10月22日 23:58</time></a> </div>
</footer>
<div class="comment-content">
<p>这个在工程中好用吗？有使用的吗？</p>
</div>
 </article>
</li>
<li id="comment-1580750" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1580750" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1580750"><time datetime="2014-10-23T08:51:25+08:00">2014年10月23日 08:51</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1580522" rel="nofollow">@liu.gong </a><br/>
Apache</p>
</div>
 </article>
</li>
<li id="comment-1586250" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1586250" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a9f78885fccc92543c36f797a51a7a83?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a9f78885fccc92543c36f797a51a7a83?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">jacky</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1586250"><time datetime="2014-10-28T14:49:13+08:00">2014年10月28日 14:49</time></a> </div>
</footer>
<div class="comment-content">
<p>可惜nanomsg不用这个做底层的调度模块呀。</p>
</div>
 </article>
</li>
<li id="comment-1627760" class="comment even thread-even depth-1">
<article id="div-comment-1627760" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/c658e2b1cd28d79640d1ff40a42f1f3c?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/c658e2b1cd28d79640d1ff40a42f1f3c?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://blog.csdn.net/liigo" class="url" rel="ugc external nofollow">Liigo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1627760"><time datetime="2014-12-12T09:13:31+08:00">2014年12月12日 09:13</time></a> </div>
</footer>
<div class="comment-content">
<p>State Threads虽然名义上叫thread，但它不是常规意义上的thread/coroutine，因为它不能并发，所有的ST threads连同它们的调度器都是在同一个系统本地线程内执行的。ST完全回避了多核环境，大大限制了自身应用范围。（libuv虽然也是单线程的IO调度(不同的是callback)，但还额外提供了让任务在其他线程执行的便利途径。）</p>
</div>
 </article>
</li>
<li id="comment-1632506" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1632506" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/c57067cb59bab56c65b4036ad48710a7?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/c57067cb59bab56c65b4036ad48710a7?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">ALiang</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1632506"><time datetime="2014-12-20T15:33:17+08:00">2014年12月20日 15:33</time></a> </div>
</footer>
<div class="comment-content">
<p>阿里云准备做流媒体CND加速了么</p>
</div>
 </article>
</li>
<li id="comment-1655680" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1655680" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1655680"><time datetime="2015-02-04T17:41:12+08:00">2015年02月04日 17:41</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1627760" rel="nofollow">@Liigo </a><br/>
回复晚了，我发现还是有很多人不了解ST应用场景。这里再强调一次，ST只负责一个用户空间进程（在ST里面叫virtual process）内部的thread协作，不负责进程之间的调度。而并发模式采用的是多核，其映射到用户空间就是vp，所以并发应用就是多个vp的并行。而ST的vp之间是隔离的，它不处理操作系统进程这些事情，是全权交给用户来处理，参考资料中ST的文档已经很详细的例子介绍如何玩并发。</p>
<p>一个vp对应一个核好处是什么，我也说过，比如不存在cpu之间的竟态，不需要无谓的上下文切换，还有缓存失效等等，实际上ngnix也是类似的做法。</p>
<p>总之，do one thing and do it well，ST只是一个库，不是一个框架，你需要自己（自由地）利用它搭建你的应用程序，明白吗？</p>
</div>
 </article>
</li>
<li id="comment-1655703" class="comment byuser comment-author-full_of_bull bypostauthor odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1655703" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1655703"><time datetime="2015-02-04T18:17:50+08:00">2015年02月04日 18:17</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1627760" rel="nofollow">@Liigo </a><br/>
回复晚了，我发现还是有很多人不了解ST应用场景。这里再强调一次，ST只负责一个用户空间进程（在ST里面叫virtual process）内部的thread协作，不负责进程之间的调度。而并发模式采用的是多核，其映射到用户空间就是vp，<strong>所谓并发是指多个vp并发而不是多thread并发。</strong>而ST的vp之间是隔离的，它不处理操作系统进程这些事情，是全权交给用户来处理，参考资料中ST的文档已经很详细的例子介绍如何玩并发。</p>
<p>一个vp对应一个核好处是什么，我也说过，比如不存在cpu之间的竟态，不需要无谓的上下文切换，还有缓存失效等等，实际上ngnix也是类似的做法。</p>
<p>总之，do one thing and do it well，ST只是一个库，不是一个框架，你需要自己（自由地）利用它搭建你的应用程序，明白吗？</p>
</div>
 </article>
</li>
<li id="comment-1655994" class="pingback even thread-even depth-1">
<div class="comment-body">
Pingback： <a href="http://www.xiaoyaochong.net/wordpress/index.php/2015/01/12/2014%e6%8a%80%e6%9c%af%e6%96%87%e7%ab%a0%e9%9b%86%e9%94%a6/" class="url" rel="ugc external nofollow">2014技术文章集锦 | 逍遥冲</a> </div>
</li>
<li id="comment-1665304" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1665304" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/9c96b8c25878de3740d6329d55283473?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/9c96b8c25878de3740d6329d55283473?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">riaqn</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1665304"><time datetime="2015-02-21T17:05:58+08:00">2015年02月21日 17:05</time></a> </div>
</footer>
<div class="comment-content">
<p>GNU有一个类似的库 Pth,看起来比ST要规范一些，至少文档要丰富一些：<br/>
<a href="http://www.gnu.org/software/pth/" rel="nofollow ugc">http://www.gnu.org/software/pth/</a></p>
</div>
 </article>
</li>
<li id="comment-1669716" class="comment byuser comment-author-full_of_bull bypostauthor even thread-even depth-1">
<article id="div-comment-1669716" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/a6e9e679d4d308a570b1e74705c026de?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://weibo.com/fullofbull" class="url" rel="ugc external nofollow">Leo</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1669716"><time datetime="2015-03-02T09:46:56+08:00">2015年03月02日 09:46</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1665304" rel="nofollow">@riaqn </a><br/>
ST与Pth的差异在“基于Multi-Threading范式”一节提及，在ST的FAQ中也提及(<a href="http://state-threads.sourceforge.net/docs/faq.html#uthreads" rel="nofollow ugc">http://state-threads.sourceforge.net/docs/faq.html#uthreads</a>)：<br/>
一、ST的thread是无优先级的非抢占式，这意味着thread是可控、易于管理的，非常适合网络IO。<br/>
二、ST会忽略所有信号处理，这意味着ST的thread要比Pth轻，处理IO速度更快。</p>
</div>
 </article>
</li>
<li id="comment-1673253" class="comment odd alt thread-odd thread-alt depth-1">
<article id="div-comment-1673253" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/9c96b8c25878de3740d6329d55283473?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/9c96b8c25878de3740d6329d55283473?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">riaqn</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1673253"><time datetime="2015-03-11T09:09:45+08:00">2015年03月11日 09:09</time></a> </div>
</footer>
<div class="comment-content">
<p><a href="#comment-1669716" rel="nofollow">@Leo </a><br/>
对, Pth更加侧重可移植/可扩展, ST也许是更加注重性能吧.<br/>
另外举个例子, ST的recv()/send()的额外参数只有一个timeout,而Pth的recv/send等参数是一个pth_event_t,这个event可以是某个时间点,或是某个fd可读, 或是某个thread进入某种状态. 而且event可以串起来, 只要其中event触发, 就算触发.</p>
<p>这个event机制在我写某些程序时还是很有用的.</p>
</div>
 </article>
</li>
<li id="comment-1687500" class="comment even thread-even depth-1">
<article id="div-comment-1687500" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/c966ddade88ad58a1bd834f66c0d74af?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/c966ddade88ad58a1bd834f66c0d74af?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">枫</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1687500"><time datetime="2015-04-08T21:55:37+08:00">2015年04月08日 21:55</time></a> </div>
</footer>
<div class="comment-content">
<p>ST尽管封装了很多阻塞API，但是并没有封装全部的，比如posix消息队列。其实协程机制还是由操作系统提供最合理。比如操作系统提供 一种 线程组间 非抢占调度策略接口，整个线程组之间不能互相抢占。而且我认为这在内核实现起来也并不麻烦。</p>
</div>
 </article>
</li>
<li id="comment-1694697" class="pingback odd alt thread-odd thread-alt depth-1">
<div class="comment-body">
Pingback： <a href="http://www.hust-zj.com/?p=31" class="url" rel="ugc external nofollow">计算机系列阅读资源推荐 « 华中大浙江校友会</a> </div>
</li>
<li id="comment-1805022" class="pingback even thread-even depth-1">
<div class="comment-body">
Pingback： <a href="http://www.fewcoo.com/2014/12/31/linus%ef%bc%9a%e4%b8%ba%e4%bd%95%e5%af%b9%e8%b1%a1%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e5%bf%85%e9%a1%bb%e6%98%af%e5%8e%9f%e5%ad%90%e7%9a%84/" class="url" rel="ugc external nofollow">Linus：为何对象引用计数必须是原子的 | 大耳门</a> </div>
</li>
<li id="comment-1829932" class="pingback odd alt thread-odd thread-alt depth-1">
<div class="comment-body">
Pingback： <a href="http://www.codeba.cc/why-c-%e7%8e%8b%e8%80%85%e5%bd%92%e6%9d%a5.html" class="url" rel="ugc external nofollow">Why C++ ? 王者归来 | | Codeba</a> </div>
</li>
<li id="comment-1902853" class="comment even thread-even depth-1">
<article id="div-comment-1902853" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/878957032b66a3aaec6392086299ad26?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/878957032b66a3aaec6392086299ad26?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">qunshu</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1902853"><time datetime="2016-11-28T23:48:16+08:00">2016年11月28日 23:48</time></a> </div>
</footer>
<div class="comment-content">
<p>腾讯的libco 博主有研究吗</p>
</div>
 </article>
</li>
<li id="comment-1924464" class="comment odd alt thread-odd thread-alt depth-1 parent">
<article id="div-comment-1924464" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/c3eb8851f20d0a55782c894ee72bdf11?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/c3eb8851f20d0a55782c894ee72bdf11?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">wxr</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1924464"><time datetime="2018-02-20T01:46:11+08:00">2018年02月20日 01:46</time></a> </div>
</footer>
<div class="comment-content">
<p>这个库1.0版本完全用的c标准库的setjmp longjmp，2.0 是自己用汇编写的寄存器和栈 的保存切换，感觉只保存了几个寄存器，好多寄存器都没保存！</p>
</div>
 </article>
<ol class="children">
<li id="comment-1924803" class="comment even depth-2">
<article id="div-comment-1924803" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/7ebe21b9a63da24f02fe7dd48245d144?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/7ebe21b9a63da24f02fe7dd48245d144?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn">gaochen</b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1924803"><time datetime="2018-03-01T16:54:02+08:00">2018年03月01日 16:54</time></a> </div>
</footer>
<div class="comment-content">
<p>深入研究winlin的SRS，发现lz在2014年已经开始介绍协程，不得不说佩服！winlin和coolshell 牛！</p>
</div>
 </article>
</li>
</ol>
</li>
<li id="comment-1936166" class="comment odd alt thread-even depth-1">
<article id="div-comment-1936166" class="comment-body">
<footer class="comment-meta">
<div class="comment-author vcard">
<img alt="" src="https://secure.gravatar.com/avatar/357a20e8c56e69d6f9734d23ef9517e8?s=50&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/357a20e8c56e69d6f9734d23ef9517e8?s=100&amp;d=mm&amp;r=g 2x" class="avatar avatar-50 photo" height="50" width="50" loading="lazy" decoding="async"/> <b class="fn"><a href="http://www.starRTC.com" class="url" rel="ugc external nofollow">starRTC</a></b><span class="says">说道：</span> </div>
<div class="comment-metadata">
<a href="/articles/12012.html#comment-1936166"><time datetime="2018-08-01T17:56:36+08:00">2018年08月01日 17:56</time></a> </div>
</footer>
<div class="comment-content">
<p>这篇文章引用了srs，而srs知道这个是通过一个50多岁的国外架构师引荐的。不得不说国外程序员很牛逼。</p>
</div>
 </article>
</li>
</ol>

</div>
</div>
</div>

</div> 
</div>

</div>

</div>

























</body></html>